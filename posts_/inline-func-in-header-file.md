---
layout: post
title: インライン関数はヘッダファイルで実装する
tags:
  - C++
  - hatenablog
---

<i><span style="color: #ff5252">2020/3/6に更新しました</span></i>

　インライン関数はC++やC99以降のC言語でサポートされています。このしくみは、マクロ関数のように<b>呼び出しのオーバヘッドを避ける</b>ことができます。

　関数におけるオーバーヘッドとは、関数の定義が別のアドレスにあることが原因で発生します。低レベルに言うと、CPUのプログラムカウンタが関数の呼び出し位置まで来ると、関数本体がおかれているメモリアドレスに飛んで戻ってくることが無駄な負荷をかけるわけです。それは、DLLなどの動的リンクの場合に顕著になります。

　このような関数のオーバーヘッドを避けるために、<b>呼び出しを定義コードに置き換えてしまおう</b>という考え方が、インライン関数の根本にあります。これは、プリプロセッサ命令としての#defineを用いたマクロ関数と似たような動作となります。

　しかしながら、#defineはコード的に置換してしまうため、コンパイラには関数として認知されません。加えて、マクロ関数は未定義の動作となる可能性があり、脆弱性の源となります。詳しくは[https://www.jpcert.or.jp/sc-rules/c-pre00-c.html:title]

　インライン関数を使うためには、コンパイラに、<b>インライン化を要請する</b>必要があります。それは、明示的なものと非明示的なものに大別されます。それぞれ次に示します。

>|cpp|
//従来のマクロ
#define five() 5

//inlineキーワードを用いた明示的インライン要請
inline int five() {
    return  5 ;
}

//メンバ関数にすることによる非明示的インライン要請
class Hoge {
public:
    int five() const {
        return 5 ;
    }
} ;

//呼び出し方は変わらない
five() ;

||<

このように、<b>inlineキーワードを先頭につける</b>か、<b>メンバ関数またはfriend関数</b>とすることで、コンパイラにインライン要請をすることができます。

　ただし、先ほど述べたように、インライン関数は定義コードで置き換えるため、そのコードが長いとオブジェクトコードが肥大化します。したがって、複雑なコードであったり、莫大な関数などは、<b>コンパイラによって拒否される可能性</b>があります。また、変更した際にコンパイルし直す必要があり、<b>バイナリのパッチを用いたアップデートができない</b>というデメリットもあります。

　インライン化は、コンパイラによってオブジェクトコードの置換を行います。したがって、<b>コンパイラは、コンパイル時に定義を知っている必要があります</b>。コンパイルはソースファイル単位でオブジェクト化するので、単一の呼び出しを除き、<b>インライン関数は、ヘッダファイルに定義を書き、#includeで定義をコンパイラに教える</b>のが望ましいと言えます。

　ただし、フレームワークによっては、リンク時にインライン化をするものもあるようですが、有名なコンパイラを使う上では、ヘッダファイルに実装するのが安全です。

<b>参考文献</b>
・Scott Meyers 著, 小林健一郎 訳『Effective C++ 第3版』2014
